var Castle = Castle || {};
Castle.CDB = Castle.CDB || {};

DataManager._databaseFiles.push({name: '$dataCastle', src: "database.cdb"});

DataManager._cdbSheets = [];
    var obj = {dataName: '$cdbQuests' + name, sheetName: 'Quests'};
    window[obj.dataName] = window[obj.dataName] || null;
    DataManager._cdbSheets.push(obj);

var $dataWaypoints = {};

    
// =============================================================================
// DataManager
//
// Modify the onLoad method to load the CDB file and process its contents,
// so that we can use the data in our game.
// =============================================================================
Castle.CDB.DataManager_onLoad = DataManager.onLoad;
DataManager.onLoad = function(object) {
    if (object === $dataCastle) {
        this.processCdb(object);
    } else {
        Castle.CDB.DataManager_onLoad.call(this, object);
    }
};

DataManager.processCdb = function(cdb) {
    // The CDB is just a big array of sheets (tables)
    // Let's print it to the console so we can see exactly what's stored there
    console.log(cdb);

    // Load a map of sheets that allows referencing them by name
    // We can't iterate blindly through them because each sheet
    // requires processing in a different way
    const sheetsByName = new Map();
    const stringToIndex = new Map();
    for (var sheet of cdb.sheets) {
        sheetsByName.set(sheet.name, sheet);
        // For each sheet, create an intermediary Map relating each item's
        // CDB string IDs to numerical index. We'll be using this to unpack
        // the table references once we finish loading the data.
        if (!sheet.name.includes("@")) { // ignore auto-generated metadata sheets
            const sheetStringToIndexMap = new Map();
            stringToIndex.set(sheet.name, sheetStringToIndexMap);
        }
    }

    // Initialize MV database of objects from CDB sheets
    for (var sheet of DataManager._cdbSheets) {
        this.loadCdbSheet(sheet.dataName, sheetsByName.get(sheet.sheetName), stringToIndex.get(sheet.sheetName));
    }

    // The CDB contains two types of objects that should be modified before we use them in our game:
    // Table References and List Ojbects (Lists, Enums and Bitflags).
    //
    // List objects store values by ID in the CDB (i.e.: Enums store the enum index - 0, 1, 2, etc. -
    // not its value - fighter, cleric, wizard, etc.). We want to translate those to their actual values.
    //
    // Table References are stored by the string ID of the object it's pointing to. We'd rather convert
    // those into the numerical ID of the object, so we can use them as indices into MV's $data objects.
    //
    // Doing this isn't strictly necessary, but it makes it easier to use the data in our game.
    this.unwrapCdb(cdb.sheets, sheetsByName, stringToIndex);

    // Since we're highjacking the normal database object format for various things,
    // we need to add dummy fields to the data generated by CastleDB to make RPG Maker
    // happy (i.e. if we don't do this, the editor crashes).
    // You have to for Classes, Enemies, Weapons, Armor and Items, if you're loading them
    // from the CDB instead of using MV's database.
    for (var sheet of DataManager._cdbSheets) {
        const paddingFunction = this['padCdb' + sheet.sheetName];
        if (typeof paddingFunction === 'function') {
            paddingFunction(window[sheet.dataName]);
        }
    }
};

// Load an MV dabatase object from a CastleDB sheet
DataManager.loadCdbSheet = function(dataName, sheet, stringToIndexMap) {
    var objArray = sheet.lines;
    for (var obj of objArray) {
        // Set the string ID => index mapping for each object,
        // increment by 1 to account for the MV null object
        // at array position 0
        obj.index += 1;

        // CastleDB calls an object's numerical ID an 'index'
        // Let's rename it to 'id', to conform to RPG Maker convention
        obj.id = obj.index;
        obj.index = null;

        // To avoid confusion, I call the unique string ID of an object in CastleDB a 'key'.
        // Here, we store the mapping from the object's string identifier (i.e.: 'leather_armor')
        // to their numerical ID in the database (i.e.: 1).
        if (obj.hasOwnProperty('key')) {
            stringToIndexMap.set(obj.key, obj.id);
        }
    }

    // MV requires the first object in each database array to be null
    //objArray.unshift(null);
    window[dataName] = objArray;
};


DataManager.unwrapCdb = function(sheets, sheetsByName, stringToIndexMap) {
    for (var sheet of sheets) {
        if (sheet.name.contains("@")) continue; // ignore empty sheets
        // Sheets can have nested lists of references, so we have to do the parsing recursively
        this.unwrapCdbSheet(sheet.name, sheetsByName, sheet.lines, sheet.columns, stringToIndexMap);
    }
};

DataManager.unwrapCdbSheet = function(sheetName, sheetsByName, lines, columns, stringToIndexMap) {
    // Some references don't need to be changed, referring to them by string ID is fine
    const ignoreReferencesTo = ["6:Param", "6:SE"];
    const ignoreEnumsFor = ["wtypeId", "atypeId", "etypeId", "itypeId"];

    // For everything else, let's modify it
    for (var line of lines) {
        if (line === null) continue;
        for (var col of columns) {
            var value = line[col.name];
            if (value === undefined) continue;
            // Ignore references to tables that don't need their references unpacked
            //const includeTable = !ignoreReferencesTo.some((element) => col.typeStr.includes(element));
            var includeTable = !ignoreReferencesTo.some(function(element) {return col.typeStr.includes(element)});

            // Table References are TypeStr = "6:TableName"
            if (col.typeStr.startsWith("6:") && includeTable) {
                var refTableName = col.typeStr.replace("6:", "");
                var sheetIdMap = stringToIndexMap.get(refTableName);
                line[col.name] = sheetIdMap.get(value);

            // Lists are TypeStr = "8"
            } else if (col.typeStr.startsWith("8")) {
                var innerLines = value;
                var innerSheetName = sheetName + "@" + col.name;
                var innerColumns = sheetsByName.get(innerSheetName).columns;
                // Lists can contain any other object, including more lists
                // Unwrap list objects recursively
                this.unwrapCdbSheet(innerSheetName, sheetsByName, innerLines, innerColumns, stringToIndexMap);

            // Enums are TypeStr = "5:Value1,Value2,Value3,..."
            } else if (col.typeStr.startsWith("5:") && col.name) {
                //const ignoreEnum = ignoreEnumsFor.some((element) => col.name === element);
                var ignoreEnum = ignoreEnumsFor.some(function(element) {return col.name === element;});
                if (ignoreEnum) continue;
                var enumString = col.typeStr.replace("5:", "");
                var enumArray = enumString.split(',');
                line[col.name] = enumArray[value];

            // Bitflags are TypeStr = "10:Flag1,Flag2,Flag3,..."
            } else if (col.typeStr.startsWith("10:")) {
                var bitflagString = col.typeStr.replace("10:", "");
                var bitflagArray = bitflagString.split(',');
                var newValue = [];
                bitflagArray.forEach(function(flag, index) {
                    if (value & (1 << index)) {
                        newValue.push(bitflagArray[index]);
                    }
                });
                line[col.name] = newValue;
            }
        }

        /* If we wanted to set the icon from within cdb, this is the code we would use
        var x = obj.icon_id.x / obj.icon_id.width;
        var y = obj.icon_id.y / obj.icon_id.height;
        obj.iconIndex = y * 16 + x; */

        // Quests need to be processed in order to be compatible with the Yanfly plugin
        if (sheetName == 'Quests') {
            line.visibleObjectives = line.visibleObjectives || [];
            line.visibleRewards = line.visibleRewards || [];

            if (line.objectives) {
                for (var i = 1; i < line.objectives.length; i++) {
                    if (!line.objectives[i].objective) continue;
                    if (line.objectives[i].visible) line.visibleObjectives.push(i);
                    var objective = line.objectives[i].objective;
                    objective = objective.replace(/\\(?!n[^\[])/g, "\\\\");
                    objective = objective.replace(/\"/g, "\\\"");
                    line.objectives[i] = "\"" + objective + "\"";
                }
            }
            if (line.rewards) {
                for (var i = 1; i < line.rewards.length; i++) {
                    if (!line.rewards[i].reward) {line.rewards[i] = "\"\""; continue;}
                    if (line.rewards[i].visible) line.visibleRewards.push(i);
                    var reward = line.rewards[i].reward;
                    reward = reward.replace("\\(?!n[^\[])", "\\\\");
                    reward = reward.replace("\"", "\\\"");
                    line.rewards[i] = "\"" + reward + "\"";
                }
            }
            if (line.description) {
                for (var i = 1; i < line.description.length; i++) {
                    var desc = line.description[i].desc;
                    //console.log(desc);
                    if (!desc || desc === "") continue;
                    desc = desc.replace(/\\(?!n[^\[])/g, "\\\\");
                    desc = desc.replace(/\"/g, "\\\"");
                    line.description[i] = "\"" + desc + "\"";
                }
            }

            var questPadding = ['difficulty', 'from', 'subtext'];
            questPadding.forEach(function (qPad) {
                line[qPad] = line[qPad] || "";
            });

            line['subtext'] = ["", "\"\""];

            // Replace the global variable to point at the cdb Quests
            $dataQuests = $cdbQuests;
        }

        if (sheetName == "Waypoints") {
            $dataWaypoints = $dataWaypoints || {};
            var identifier = line.identifier;
            $dataWaypoints[identifier] = $dataWaypoints[identifier] || {};
            $dataWaypoints[identifier].index = line.index;
            $dataWaypoints[identifier].displayName = line.displayName;
            $dataWaypoints[identifier].mapId = line.mapId;
            $dataWaypoints[identifier].eventId = line.eventId;
            $dataWaypoints[identifier].xOffset = line.xOffset;
            $dataWaypoints[identifier].yOffset = line.yOffset;
            $dataWaypoints[identifier].followersVisible = line.followersVisible;
        }
    }
};